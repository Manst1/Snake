<!DOCTYPE html>
<html>
<head>
  <title>Snake - April Fool's Edition</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      height: 100vh; 
      margin: 0; 
      transition: background-color 0.3s, color 0.3s;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    canvas { 
      border: 2px solid; 
      transition: border-color 0.3s;
    }
    .theme-toggle {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s, color 0.3s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <button class="theme-toggle" id="themeToggle">Toggle Theme</button>
  
<script>
let snake;
let food;
let gridSize = 20;
let tileSize = 20;
let gameOver = false;
let score = 0;
let started = false;
let nextDirection = null;
let lastUpdateTime = 0;
let moveInterval = 143;
let isDarkMode = false;
let isAprilFoolsMode = false;
let currentTheme = {bg: null, snake: null, food: null, text: null, border: null};

function setup() {
  createCanvas(400, 400);
  
  // Check if today is April 1st
  const today = new Date();
  isAprilFoolsMode = today.getMonth() === 3 && today.getDate() === 1; // April is month 3 (0-indexed)
  
  // Set initial theme based on time of day
  const hour = today.getHours();
  isDarkMode = hour >= 22 || hour < 4;
  applyTheme();
  
  resetGame();
}

function resetGame() {
  snake = new Snake();
  food = createFood();
  gameOver = false;
  score = 0;
  started = false;
  nextDirection = null;
  lastUpdateTime = 0;
  
  // Reset to default theme on restart
  if (!isAprilFoolsMode) {
    const hour = new Date().getHours();
    isDarkMode = hour >= 22 || hour < 4;
    applyTheme();
  }
}

function draw() {
  // Clear canvas with appropriate background
  if (isAprilFoolsMode && currentTheme.bg) {
    background(currentTheme.bg);
  } else if (isDarkMode) {
    background(40);
  } else {
    background(220);
  }
  
  if (!gameOver) {
    if (started) {
      // Time-based movement instead of frame-based
      const currentTime = millis();
      if (currentTime - lastUpdateTime > moveInterval) {
        snake.update();
        lastUpdateTime = currentTime;
      }
    }
    snake.show();
    if (snake.eat(food)) {
      food = createFood();
      score++;
      
      // If it's April Fool's mode, change to a random theme
      if (isAprilFoolsMode) {
        setRandomTheme();
      }
    }
    
    // Draw food
    if (isAprilFoolsMode && currentTheme.food) {
      fill(currentTheme.food);
    } else if (isDarkMode) {
      fill(255, 100, 100);
    } else {
      fill(255, 0, 0);
    }
    rect(food.x * tileSize, food.y * tileSize, tileSize, tileSize);
    
    // Draw score
    if (isAprilFoolsMode && currentTheme.text) {
      fill(currentTheme.text);
    } else if (isDarkMode) {
      fill(255);
    } else {
      fill(0);
    }
    textSize(20);
    textAlign(LEFT, TOP);
    text(`Score: ${score}`, 10, 30);
    
    if (!started) {
      textSize(24);
      textAlign(CENTER, CENTER);
      if (isAprilFoolsMode && currentTheme.text) {
        fill(currentTheme.text);
      } else if (isDarkMode) {
        fill(255);
      } else {
        fill(0);
      }
      text('Press an arrow key to start', width / 2, height / 2);
    }
  } else {
    // Game over screen
    if (isAprilFoolsMode && currentTheme.text) {
      fill(currentTheme.text);
    } else if (isDarkMode) {
      fill(255);
    } else {
      fill(0);
    }
    textSize(32);
    textAlign(CENTER, CENTER);
    text('Game Over', width / 2, height / 2);
    text(`Score: ${score}`, width / 2, height / 2 + 40);
    textSize(24);
    text('Press R to restart', width / 2, height / 2 + 80);
  }
}

function keyPressed() {
  if (gameOver) {
    if (keyCode === 82) { // 'R' key
      resetGame();
    }
    return;
  }
  
  // Arrow keys and WASD controls
  if ((keyCode === UP_ARROW || keyCode === 87) && snake.ydir !== 1) { // W or Up
    nextDirection = { x: 0, y: -1 };
  } else if ((keyCode === DOWN_ARROW || keyCode === 83) && snake.ydir !== -1) { // S or Down
    nextDirection = { x: 0, y: 1 };
  } else if ((keyCode === LEFT_ARROW || keyCode === 65) && snake.xdir !== 1) { // A or Left
    nextDirection = { x: -1, y: 0 };
  } else if ((keyCode === RIGHT_ARROW || keyCode === 68) && snake.xdir !== -1) { // D or Right
    nextDirection = { x: 1, y: 0 };
  }
  
  // Start the game when a valid direction is set
  if (nextDirection && !started) {
    started = true;
    lastUpdateTime = millis();
  }
}

class Snake {
  constructor() {
    this.body = [{ x: 10, y: 10 }];
    this.xdir = 0;
    this.ydir = 0;
  }

  update() {
    if (this.xdir === 0 && this.ydir === 0 && !nextDirection) return;
    
    // Apply the next direction only at the start of the update cycle
    if (nextDirection) {
      this.xdir = nextDirection.x;
      this.ydir = nextDirection.y;
      nextDirection = null; // Clear the direction after applying
    }
    
    if (this.xdir === 0 && this.ydir === 0) return;
    
    let head = { x: this.body[0].x + this.xdir, y: this.body[0].y + this.ydir };
    
    // Wall collision check
    if (head.x < 0 || head.x >= width / tileSize || head.y < 0 || head.y >= height / tileSize) {
      gameOver = true;
      return;
    }
    
    // Self collision check, excluding the head
    for (let i = 1; i < this.body.length; i++) {
      if (head.x === this.body[i].x && head.y === this.body[i].y) {
        gameOver = true;
        return;
      }
    }
    
    // Update body: add new head and remove tail
    this.body.unshift(head);
    this.body.pop();
  }

  show() {
    if (isAprilFoolsMode && currentTheme.snake) {
      fill(currentTheme.snake);
    } else if (isDarkMode) {
      fill(100, 255, 100);
    } else {
      fill(0, 200, 0);
    }
    for (let segment of this.body) {
      rect(segment.x * tileSize, segment.y * tileSize, tileSize, tileSize);
    }
  }

  eat(food) {
    let head = this.body[0];
    if (head.x === food.x && head.y === food.y) {
      this.body.push({ ...this.body[this.body.length - 1] });
      return true;
    }
    return false;
  }
}

function createFood() {
  let x = floor(random(width / tileSize));
  let y = floor(random(height / tileSize));
  for (let segment of snake.body) {
    if (x === segment.x && y === segment.y) {
      return createFood();
    }
  }
  return { x, y };
}

function applyTheme() {
  if (isDarkMode) {
    document.body.style.backgroundColor = '#222';
    document.body.style.color = '#fff';
    document.querySelector('canvas').style.borderColor = '#fff';
    document.getElementById('themeToggle').style.backgroundColor = '#333';
    document.getElementById('themeToggle').style.color = '#fff';
    document.getElementById('themeToggle').innerText = 'Light Mode';
  } else {
    document.body.style.backgroundColor = '#f0f0f0';
    document.body.style.color = '#000';
    document.querySelector('canvas').style.borderColor = '#000';
    document.getElementById('themeToggle').style.backgroundColor = '#ddd';
    document.getElementById('themeToggle').style.color = '#000';
    document.getElementById('themeToggle').innerText = 'Dark Mode';
  }
}

function setRandomTheme() {
  // Generate random colors for the theme
  const hue = random(360);
  currentTheme = {
    bg: color(random(255), random(255), random(255)),
    snake: color(random(255), random(255), random(255)),
    food: color(random(255), random(255), random(255)),
    text: color(random(255), random(255), random(255)),
    border: color(random(255), random(255), random(255))
  };
  
  // Apply the theme to UI elements
  document.body.style.backgroundColor = `rgb(${red(currentTheme.bg)}, ${green(currentTheme.bg)}, ${blue(currentTheme.bg)})`;
  document.querySelector('canvas').style.borderColor = `rgb(${red(currentTheme.border)}, ${green(currentTheme.border)}, ${blue(currentTheme.border)})`;
  document.body.style.color = `rgb(${red(currentTheme.text)}, ${green(currentTheme.text)}, ${blue(currentTheme.text)})`;
  
  // Set button and control colors with sufficient contrast
  const bgBrightness = (red(currentTheme.bg) + green(currentTheme.bg) + blue(currentTheme.bg)) / 3;
  const btnColor = bgBrightness > 128 ? '#000' : '#fff';
  const btnBg = bgBrightness > 128 ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.7)';
  
  document.getElementById('themeToggle').style.backgroundColor = btnBg;
  document.getElementById('themeToggle').style.color = btnColor;
}

// Theme toggle functionality
document.getElementById('themeToggle').addEventListener('click', function() {
  if (isAprilFoolsMode) {
    // In April Fool's mode, just generate a new random theme
    setRandomTheme();
  } else {
    // Normal mode behavior
    isDarkMode = !isDarkMode;
    applyTheme();
  }
});
</script>
</body>
</html>
