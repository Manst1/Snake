<!DOCTYPE html>
<html>
<head>
  <title>Snake - April Fool's Edition</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      height: 100vh; 
      margin: 0; 
      transition: background-color 0.3s, color 0.3s;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
    }
    canvas { 
      border: 2px solid; 
      transition: border-color 0.3s;
      max-width: 100%;
      max-height: 100%;
      touch-action: none; /* Prevent default touch behaviors */
    }
    .theme-toggle {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 12px 16px; /* Larger padding for touch */
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      font-size: 16px; /* Larger font for readability */
      transition: background-color 0.3s, color 0.3s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 10;
    }
    @media (max-width: 600px) {
      .theme-toggle {
        top: 10px;
        left: 10px;
        padding: 10px 14px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <button class="theme-toggle" id="themeToggle">Toggle Theme</button>
  
<script>
let snake;
let food;
let gridSize = 20;
let tileSize;
let gameOver = false;
let score = 0;
let started = false;
let nextDirection = null;
let lastUpdateTime = 0;
let moveInterval = 143;
let isDarkMode = false;
let isAprilFoolsMode = false;
let currentTheme = {bg: null, snake: null, food: null, text: null, border: null};
let touchStartX = 0;
let touchStartY = 0;
let touchThreshold = 30; // Minimum swipe distance in pixels

function setup() {
  // Responsive canvas size
  let size = min(windowWidth * 0.9, windowHeight * 0.7, 400);
  size = floor(size / gridSize) * gridSize; // Ensure size is multiple of gridSize
  tileSize = size / gridSize;
  createCanvas(size, size);
  
  // Check if today is April 1st
  const today = new Date();
  isAprilFoolsMode = today.getMonth() === 3 && today.getDate() === 1;
  
  // Set initial theme based on time of day
  const hour = today.getHours();
  isDarkMode = hour >= 22 || hour < 4;
  applyTheme();
  
  resetGame();

  // Add touch event listeners
  canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
  canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
}

function windowResized() {
  let size = min(windowWidth * 0.9, windowHeight * 0.7, 400);
  size = floor(size / gridSize) * gridSize;
  tileSize = size / gridSize;
  resizeCanvas(size, size);
}

function resetGame() {
  snake = new Snake();
  food = createFood();
  gameOver = false;
  score = 0;
  started = false;
  nextDirection = null;
  lastUpdateTime = 0;
  
  if (!isAprilFoolsMode) {
    const hour = new Date().getHours();
    isDarkMode = hour >= 22 || hour < 4;
    applyTheme();
  }
}

function draw() {
  if (isAprilFoolsMode && currentTheme.bg) {
    background(currentTheme.bg);
  } else if (isDarkMode) {
    background(40);
  } else {
    background(220);
  }
  
  if (!gameOver) {
    if (started) {
      const currentTime = millis();
      if (currentTime - lastUpdateTime > moveInterval) {
        snake.update();
        lastUpdateTime = currentTime;
      }
    }
    snake.show();
    if (snake.eat(food)) {
      food = createFood();
      score++;
      if (isAprilFoolsMode) {
        setRandomTheme();
      }
    }
    
    if (isAprilFoolsMode && currentTheme.food) {
      fill(currentTheme.food);
    } else if (isDarkMode) {
      fill(255, 100, 100);
    } else {
      fill(255, 0, 0);
    }
    rect(food.x * tileSize, food.y * tileSize, tileSize, tileSize);
    
    if (isAprilFoolsMode && currentTheme.text) {
      fill(currentTheme.text);
    } else if (isDarkMode) {
      fill(255);
    } else {
      fill(0);
    }
    textSize(min(20, tileSize));
    textAlign(LEFT, TOP);
    text(`Score: ${score}`, 10, 10);
    
    if (!started) {
      textSize(min(24, tileSize * 1.2));
      textAlign(CENTER, CENTER);
      if (isAprilFoolsMode && currentTheme.text) {
        fill(currentTheme.text);
      } else if (isDarkMode) {
        fill(255);
      } else {
        fill(0);
      }
      text('Swipe or press an arrow key to start', width / 2, height / 2);
    }
  } else {
    if (isAprilFoolsMode && currentTheme.text) {
      fill(currentTheme.text);
    } else if (isDarkMode) {
      fill(255);
    } else {
      fill(0);
    }
    textSize(min(32, tileSize * 1.6));
    textAlign(CENTER, CENTER);
    text('Game Over', width / 2, height / 2);
    text(`Score: ${score}`, width / 2, height / 2 + tileSize * 2);
    textSize(min(24, tileSize * 1.2));
    text('Tap or press R to restart', width / 2, height / 2 + tileSize * 4);
  }
}

function keyPressed() {
  if (gameOver) {
    if (keyCode === 82) { // 'R' key
      resetGame();
    }
    return;
  }
  
  if ((keyCode === UP_ARROW || keyCode === 87) && snake.ydir !== 1) {
    nextDirection = { x: 0, y: -1 };
  } else if ((keyCode === DOWN_ARROW || keyCode === 83) && snake.ydir !== -1) {
    nextDirection = { x: 0, y: 1 };
  } else if ((keyCode === LEFT_ARROW || keyCode === 65) && snake.xdir !== 1) {
    nextDirection = { x: -1, y: 0 };
  } else if ((keyCode === RIGHT_ARROW || keyCode === 68) && snake.xdir !== -1) {
    nextDirection = { x: 1, y: 0 };
  }
  
  if (nextDirection && !started) {
    started = true;
    lastUpdateTime = millis();
  }
}

function handleTouchStart(event) {
  event.preventDefault();
  if (gameOver) {
    resetGame();
    return;
  }
  const touch = event.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
}

function handleTouchMove(event) {
  event.preventDefault();
  if (gameOver || !event.touches.length) return;
  
  const touch = event.touches[0];
  const deltaX = touch.clientX - touchStartX;
  const deltaY = touch.clientY - touchStartY;
  
  if (abs(deltaX) > abs(deltaY) && abs(deltaX) > touchThreshold) {
    if (deltaX > 0 && snake.xdir !== -1) {
      nextDirection = { x: 1, y: 0 }; // Right
    } else if (deltaX < 0 && snake.xdir !== 1) {
      nextDirection = { x: -1, y: 0 }; // Left
    }
    touchStartX = touch.clientX; // Reset to prevent repeated inputs
  } else if (abs(deltaY) > touchThreshold) {
    if (deltaY > 0 && snake.ydir !== -1) {
      nextDirection = { x: 0, y: 1 }; // Down
    } else if (deltaY < 0 && snake.ydir !== 1) {
      nextDirection = { x: 0, y: -1 }; // Up
    }
    touchStartY = touch.clientY; // Reset to prevent repeated inputs
  }
  
  if (nextDirection && !started) {
    started = true;
    lastUpdateTime = millis();
  }
}

class Snake {
  constructor() {
    this.body = [{ x: 10, y: 10 }];
    this.xdir = 0;
    this.ydir = 0;
  }

  update() {
    if (this.xdir === 0 && this.ydir === 0 && !nextDirection) return;
    
    if (nextDirection) {
      this.xdir = nextDirection.x;
      this.ydir = nextDirection.y;
      nextDirection = null;
    }
    
    if (this.xdir === 0 && this.ydir === 0) return;
    
    let head = { x: this.body[0].x + this.xdir, y: this.body[0].y + this.ydir };
    
    if (head.x < 0 || head.x >= width / tileSize || head.y < 0 || head.y >= height / tileSize) {
      gameOver = true;
      return;
    }
    
    for (let i = 1; i < this.body.length; i++) {
      if (head.x === this.body[i].x && head.y === this.body[i].y) {
        gameOver = true;
        return;
      }
    }
    
    this.body.unshift(head);
    this.body.pop();
  }

  show() {
    if (isAprilFoolsMode && currentTheme.snake) {
      fill(currentTheme.snake);
    } else if (isDarkMode) {
      fill(100, 255, 100);
    } else {
      fill(0, 200, 0);
    }
    for (let segment of this.body) {
      rect(segment.x * tileSize, segment.y * tileSize, tileSize, tileSize);
    }
  }

  eat(food) {
    let head = this.body[0];
    if (head.x === food.x && head.y === food.y) {
      this.body.push({ ...this.body[this.body.length - 1] });
      return true;
    }
    return false;
  }
}

function createFood() {
  let x = floor(random(width / tileSize));
  let y = floor(random(height / tileSize));
  for (let segment of snake.body) {
    if (x === segment.x && y === segment.y) {
      return createFood();
    }
  }
  return { x, y };
}

function applyTheme() {
  if (isDarkMode) {
    document.body.style.backgroundColor = '#222';
    document.body.style.color = '#fff';
    document.querySelector('canvas').style.borderColor = '#fff';
    document.getElementById('themeToggle').style.backgroundColor = '#333';
    document.getElementById('themeToggle').style.color = '#fff';
    document.getElementById('themeToggle').innerText = 'Light Mode';
  } else {
    document.body.style.backgroundColor = '#f0f0f0';
    document.body.style.color = '#000';
    document.querySelector('canvas').style.borderColor = '#000';
    document.getElementById('themeToggle').style.backgroundColor = '#ddd';
    document.getElementById('themeToggle').style.color = '#000';
    document.getElementById('themeToggle').innerText = 'Dark Mode';
  }
}

function setRandomTheme() {
  const hue = random(360);
  currentTheme = {
    bg: color(random(255), random(255), random(255)),
    snake: color(random(255), random(255), random(255)),
    food: color(random(255), random(255), random(255)),
    text: color(random(255), random(255), random(255)),
    border: color(random(255), random(255), random(255))
  };
  
  document.body.style.backgroundColor = `rgb(${red(currentTheme.bg)}, ${green(currentTheme.bg)}, ${blue(currentTheme.bg)})`;
  document.querySelector('canvas').style.borderColor = `rgb(${red(currentTheme.border)}, ${green(currentTheme.border)}, ${blue(currentTheme.border)})`;
  document.body.style.color = `rgb(${red(currentTheme.text)}, ${green(currentTheme.text)}, ${blue(currentTheme.text)})`;
  
  const bgBrightness = (red(currentTheme.bg) + green(currentTheme.bg) + blue(currentTheme.bg)) / 3;
  const btnColor = bgBrightness > 128 ? '#000' : '#fff';
  const btnBg = bgBrightness > 128 ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.7)';
  
  document.getElementById('themeToggle').style.backgroundColor = btnBg;
  document.getElementById('themeToggle').style.color = btnColor;
}

document.getElementById('themeToggle').addEventListener('click', function() {
  if (isAprilFoolsMode) {
    setRandomTheme();
  } else {
    isDarkMode = !isDarkMode;
    applyTheme();
  }
});
</script>
</body>
</html>
